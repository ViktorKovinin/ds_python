
# *** Функции ***

# функции - это обычно  "фабрики", которые на вход принимают какие-либо данные и на выход возвращают другие данные 

# 1 вариант. Функция, которая на вход ничего не принимает и на выход ничего не возвращает   

# def func_1():
#     print("Hello world")

def func_2():
    name = "Victor"
    print(f"Hello {name}")


# 2 вариант. Функция, которая принимает данные (имеет вход(-ы)(аргументы - входы в функцию)), но ничего не возвращает (не имеется выхода)

def func_3(argument_1, arg_2):  #  в программировании вход функции называется аргументом. Аргументы это специализированные переменные
    result = argument_1 + arg_2
    # docstring -  функция имеет докстринг - это то, что делает функция 
    print(result)

# вызов функции c передачей параметров для аргументов

# func_3(100,55)    

# 2.1 вариант. Функция, принимающая данные, но ничего не возвращает 
# причем аргументы имеют значение по умолчанию  

def func_4(arg_1, arg_2, arg_3=10):  
    result = arg_1 + arg_2 * arg_3
    print(result) 

# func_4(100,20,5)

# 2.2 вариант.Функция, принимающая данные, но ничего не возвращает
# позиционные параметры

def func_5(arg_1=10, arg_2=20, arg_3=30):  
    result = arg_1 + arg_2 + arg_3
    print(result) 

# func_5(2, 3, 4)
# func_5(100, 20 ) 

# 2.3 вариант.Функция, принимающая данные, но ничего не возвращает
# именованные параметры (именованная передача параметров)

def func_6(arg_1=10, arg_2=20, arg_3=30):  
    result = arg_1 + arg_2 + arg_3
    print(result) 

# func_6(arg_3=100, arg_1=5)

# 2.4 вариант.Функция, принимающая данные, но ничего не возвращает
# множественные позиционные парметры

def func_7(*args):
    print(args)
# можно передвать произвольное количество позиционных параметров
# они будут упакованы в виде кортежа 
# func_7(10,29,30)

def func_8(*args): 
# функция, которая складывает произвольное коичество параметров 

    result = 0
    for num in args:
        result += num
    print(result)

# func_8(100,200)

# 2.4 вариант.Функция, принимающая данные, но ничего не возвращает
# множественные именованные парметры

def func_9(**args):
    print(args)


# можно передавать произвольное количество именованных параметров
# они будут упакованы ввиде словаря
# func_9(x=100, y=200, z=300)

# импортируем математический модуль
import math 

def distance_caslculate(**args):

# Функция, которая вычисляет дистанцию от начала координат(0,0,0) до точки с координатами (x,y,z)    

# функция keys будет хранить список ключей аргументов из args

    keys = list(args.keys())

# для вычисления дистанции применяем теорему Пифагора

    summa = 0

    # извлекаем все ключи из списка ключей
    for axis in keys:

        # суммирование квадратов катетов(значений координатных осей) 
        summa += args[axis] ** 2

# извлечение квадратного корня

    distance = math.sqrt(summa)    

    print(f"Дистанция: {distance}")

# # вызов функции
# distance_caslculate (x=10, y=20, z = 10, a=5)


# вариант 3. Функция, которая принимает параметры и возвращает результаты

def func_10(x,y):
    summa = x + y
    return summa

# вызов функции и присвоение возвращаемого значения в переменную

result = func_10(10,20)

# print(result)

# Передача возвращаемого значения из одной функции в другую "передача значений на лету" (парадигма конкурирующая с парадигмой объектно-ориентированного программирования)
# print(func_10(1,2))


# функция, возвращающая 2 значения
def func_11(x,y):
    res_1 = x**2
    res_2 = y**3
    return res_1, res_2

# print(func_11(2,4))

# присвоение нескольких возвращаемых значений в переменные 
a,b = func_11(2,4)

# print(a,b)

# *** Безымянные функции (лямбда-функции, лямбда - выражения) ***

# Создание лямбда - выражения
foo = lambda x, y: (x * y) + (x * y)

# вызов лямбда - выражения с передачей паметров и передача возвращаемого значения "на лету" 
# print(foo(2, 3))

# вызов лямбда - выражения с передачей параметров и присвоение возвращаемого значния в переменную
res = foo(2, 2)
# print(res)

# пример. Лямбда внутри генератора списка

my_list = [(lambda arg: arg ** 2)(i) for i in range(1,10)]  

# print(my_list)

# пример. Лямбда внутри списка
lambda_list = [lambda x, y: x + y, lambda x,y: x * y ] 

# res = lambda_list[0](10, 20)

res = lambda_list[1](10, 20)

# print(res)

# пример. Лямбда внутри словаря
lambda_dict = {"сумма": lambda x, y: x + y, "произведение": lambda x,y: x * y}

res = lambda_dict["сумма"](20,30)

# print(res)

# *** декораторы *** патерн программирования (патерны - шаблоны программировния, шаблоны проектирования). Деократоры - это патерны поведения. Есть еще пораждающие патерны и др.

# декораторы - декорируют функции, то есть добавляют дополнительный функционал обернутым функциям

# целевая функция
def my_func_1():
    print("hello!") 

def my_func_2():
    print("привет!") 

# собственно функция - декоратор
def decorator(func):
    '''
    func: аргумент, которому присваивается объект целевой функции
    '''
    # функция - обёртка
    def wrapper():
        # код, который выполняется ДО выполнения целевой функции
        print("код, который выполняется ДО выполнения целевой функции")
        
        # вызывается целевая функция из аргумента 
        func()
        
        # код, который выполняется ДО выполнения целевой функции
        print("bar")

        #  возврат объекта функции - обёртки
    return wrapper

# целевая функция
def my_func_1():
    print("hello!") 


# присваиваем задекорированную функцию в старое название 
my_func_1 = decorator(my_func_1)

# *** новый способ применения декоратора ***
# целевые функции

@decorator
def my_func_2():
    print("hello!") 

@decorator
def my_func_3():
    print("привет!") 



# вызов задекорированной функции
# my_func_3()

# *** декорирование функции, которая имеет аргументы и возвращает значения

def decorator_1(func):
    def wrapper (a,b):
        print (f"ДО: {a}, {b}")
        print (func(a,b))
        print(f"ПОСЛЕ: {a*2}, {b*2}")
        return res
    return wrapper

@decorator_1
def target_func(x, y):
    return x**y

print(target_func(10,2))

#  модуль pygame - на нем можно создавать игры
 

